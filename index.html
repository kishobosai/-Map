<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8ZD2TRY287"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8ZD2TRY287');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>どこでも北海道マップ</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    /* Tailwindのデフォルトフォントを適用 */
    body { font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
    /* アイコンの表示スタイル調整 */
    i[data-lucide] { display: inline-block; }
  </style>
</head>
<body class="relative w-full h-screen bg-[#e5e7eb] overflow-hidden">

  <!-- ローディング画面 -->
  <div id="loading-overlay" class="absolute inset-0 z-[2000] bg-white/80 flex flex-col items-center justify-center backdrop-blur-sm transition-opacity duration-300">
    <div class="w-10 h-10 border-4 border-red-500 border-t-transparent rounded-full animate-spin mb-4"></div>
    <div class="text-gray-700 font-medium tracking-wide">地理データを読み込み中...</div>
    <div class="text-xs text-gray-400 mt-2">日本全国の高精細なデータを取得しています</div>
  </div>

  <!-- マップコンテナ -->
  <div id="map" class="w-full h-full absolute inset-0 z-0"></div>
  
  <!-- 中央の十字レティクル（ターゲット） -->
  <div class="absolute inset-0 pointer-events-none z-[1000] flex items-center justify-center">
    <div class="relative w-10 h-10 opacity-50">
      <div class="absolute top-1/2 left-0 w-full h-[2px] bg-gray-900 -translate-y-1/2 rounded-full"></div>
      <div class="absolute left-1/2 top-0 w-[2px] h-full bg-gray-900 -translate-x-1/2 rounded-full"></div>
      <div class="absolute inset-0 border-2 border-gray-900 rounded-full scale-50"></div>
    </div>
  </div>

  <!-- タイトル・説明パネル (左上) -->
  <div class="absolute top-4 left-4 z-[1000] bg-white/95 backdrop-blur-md p-3 sm:p-5 rounded-xl sm:rounded-2xl shadow-xl border border-gray-100 max-w-[55%] sm:max-w-[320px]">
    <h1 class="text-sm sm:text-xl font-bold text-gray-800 flex items-center gap-1.5 sm:gap-2 sm:mb-3">
      <i data-lucide="map" class="w-4 h-4 sm:w-6 sm:h-6 text-red-500 shrink-0"></i>
      <span id="app-title-text" class="truncate">どこでも北海道マップ</span>
    </h1>
    
    <div class="hidden sm:block">
      <p class="text-sm text-gray-600 mb-4 leading-relaxed">
        地図をドラッグすると、画面中央に選択した地域がついてきます。世界中の様々な地域と実際の大きさを比べてみましょう。
      </p>
      <div class="flex items-start gap-2 text-xs text-blue-800 bg-blue-50/80 p-3 rounded-xl border border-blue-100 mb-4">
        <i data-lucide="info" class="w-4 h-4 shrink-0 mt-0.5 text-blue-500"></i>
        <p class="leading-relaxed">
          メルカトル図法の特性を完全再現。赤道に近づくほど小さくなり、極地に近づくほど巨大化し、さらに図形自体も歪みます。
        </p>
      </div>
    </div>

    <!-- 地域選択プルダウンと図形操作 -->
    <div class="mt-2 sm:mt-0">
      <select id="region-select" class="w-full bg-gray-50/90 border border-gray-200 text-gray-800 text-xs sm:text-sm rounded-xl focus:ring-blue-500 focus:border-blue-500 block p-2 sm:p-2.5 shadow-inner cursor-pointer outline-none transition-all">
        <option value="北海道">北海道 (読み込み中...)</option>
      </select>
      
      <!-- 【追加】図形の操作パネル（折りたたみ式） -->
      <div class="mt-2 sm:mt-3 border-t border-gray-100 pt-2 sm:pt-3">
        <button id="btn-toggle-controls" class="flex items-center justify-between w-full text-xs text-gray-600 hover:text-gray-800 transition-colors">
          <span class="flex items-center gap-1.5 font-medium"><i data-lucide="sliders" class="w-3.5 h-3.5 text-blue-500"></i> 図形の操作（回転・反転）</span>
          <i data-lucide="chevron-down" id="icon-toggle-controls" class="w-3.5 h-3.5 transition-transform duration-300 text-gray-400"></i>
        </button>
        
        <div id="controls-panel" class="hidden mt-3 space-y-2.5">
          <div class="flex items-center gap-2">
            <button id="btn-flip-x" class="flex-1 py-1.5 bg-gray-50 hover:bg-gray-100 border border-gray-200 rounded-lg text-xs text-gray-700 transition-all">左右反転</button>
            <button id="btn-flip-y" class="flex-1 py-1.5 bg-gray-50 hover:bg-gray-100 border border-gray-200 rounded-lg text-xs text-gray-700 transition-all">上下反転</button>
          </div>
          <div class="flex items-center gap-2 bg-gray-50 px-2 py-1.5 rounded-lg border border-gray-100">
            <i data-lucide="rotate-cw" class="w-3.5 h-3.5 text-gray-400 shrink-0"></i>
            <input type="range" id="rotation-slider" min="-180" max="180" value="0" class="flex-1 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer outline-none">
            <span id="rotation-display" class="text-xs text-gray-600 w-8 text-right font-mono shrink-0">0°</span>
          </div>
          <div class="flex justify-end pt-1">
            <button id="btn-reset-transform" class="text-[10px] sm:text-xs text-blue-600 hover:bg-blue-50 px-2 py-1 rounded transition-colors flex items-center gap-1">
              <i data-lucide="rotate-ccw" class="w-3 h-3"></i> 向きをリセット
            </button>
          </div>
        </div>
      </div>

      <!-- バグ報告リンク -->
      <div class="mt-2 text-right">
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSfh55H0B8LKC9N7ed3hGXwA4duPPNhTMbcT6oQgCS4tX4_CjA/viewform?usp=header" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-[10px] sm:text-xs text-gray-400 hover:text-gray-600 transition-colors cursor-pointer">
          <i data-lucide="bug" class="w-3 h-3"></i>
          <span>バグ・不具合を報告</span>
        </a>
      </div>
    </div>
  </div>

  <!-- ステータスパネル (右上) -->
  <div class="absolute top-4 right-4 z-[1000] bg-white/95 backdrop-blur-md p-3 sm:p-5 rounded-xl sm:rounded-2xl shadow-xl border border-gray-100 min-w-min sm:min-w-[220px]">
    <div class="hidden sm:block">
      <div class="text-xs font-semibold text-gray-400 tracking-wider mb-1 uppercase">現在地の中心座標</div>
      <div id="coords-display" class="font-mono text-sm text-gray-700 mb-4 bg-gray-50 p-2 rounded-lg border border-gray-100">
        N 35.681°<br/>E 139.767°
      </div>
    </div>
    
    <div class="text-[10px] sm:text-xs font-semibold text-gray-400 tracking-wider mb-0 sm:mb-1 uppercase leading-tight">
      見た目の大きさ <br class="hidden sm:inline"/><span class="text-[8px] sm:text-[10px] font-normal lowercase">(対 本来の位置)</span>
      <!-- スケール注釈（元に戻しました） -->
      <div id="scale-note" class="text-[8px] sm:text-[10px] text-gray-400 mt-0.5 normal-case font-medium">※中心付近の目安値</div>
    </div>
    <div class="flex items-baseline gap-1 mt-0.5 sm:mt-1">
      <span id="scale-display" class="text-xl sm:text-3xl font-black text-red-500 tracking-tight">100.0</span>
      <span class="text-xs sm:text-sm text-gray-500 font-medium">%</span>
    </div>
  </div>

  <!-- コントロールボタン (下部中央) -->
  <div class="absolute bottom-6 sm:bottom-8 left-1/2 -translate-x-1/2 z-[1000] flex gap-2 sm:gap-3 w-full max-w-[90%] sm:max-w-sm justify-center">
    <button id="btn-home" class="flex-1 flex items-center justify-center gap-1.5 sm:gap-2 bg-white px-3 sm:px-4 py-2.5 sm:py-3.5 rounded-xl sm:rounded-2xl shadow-lg font-medium text-sm sm:text-base text-gray-700 hover:bg-gray-50 transition-all active:scale-95 border border-gray-200 cursor-pointer">
      <i data-lucide="map-pin" class="w-4 h-4 sm:w-5 sm:h-5 text-red-500"></i>
      元の位置
    </button>
    <button id="btn-current-location" class="flex-1 flex items-center justify-center gap-1.5 sm:gap-2 bg-blue-600 px-3 sm:px-4 py-2.5 sm:py-3.5 rounded-xl sm:rounded-2xl shadow-lg font-medium text-sm sm:text-base text-white hover:bg-blue-700 transition-all active:scale-95 cursor-pointer">
      <i data-lucide="navigation" class="w-4 h-4 sm:w-5 sm:h-5"></i>
      現在地へ
    </button>
  </div>

  <!-- トースト通知 -->
  <div id="toast" class="hidden absolute bottom-24 left-1/2 -translate-x-1/2 z-[1100] bg-gray-800/90 backdrop-blur-sm text-white px-6 py-3 rounded-full shadow-2xl text-sm font-medium animate-bounce transition-opacity">
    <span id="toast-message"></span>
  </div>

  <!-- 初回アクセス時の留意事項モーダル -->
  <div id="notice-modal" class="fixed inset-0 z-[3000] flex items-center justify-center bg-gray-900/40 backdrop-blur-sm p-4 transition-opacity duration-300">
    <div class="bg-white/95 backdrop-blur-md rounded-2xl shadow-2xl max-w-md w-full p-6 relative transform transition-all">
      <h2 class="text-lg sm:text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
        <i data-lucide="alert-triangle" class="w-5 h-5 sm:w-6 sm:h-6 text-yellow-500"></i>
        サイト利用時の留意事項
      </h2>
      <div class="text-sm text-gray-600 leading-relaxed space-y-3">
        <p>
          メルカトル図法の特性を再現しているため、極地に近づくほど図形は巨大化し、形も歪みます。
        </p>
        <p class="text-xs sm:text-sm bg-gray-50 p-3 sm:p-4 rounded-xl border border-gray-200">
          <span class="font-bold text-gray-700">※本マップは直感的なスケール感を体験するためのシミュレーターです。</span><br>
          地球を球体として近似計算しているため、最大0.5パーセント（北海道のサイズで最大1〜2km程度）の誤差が含まれており、厳密な測量や面積計算には使用できません。
        </p>
      </div>
      <div class="mt-6 flex justify-end">
        <button id="close-notice-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-medium text-sm sm:text-base py-2.5 px-6 rounded-xl transition-all active:scale-95 cursor-pointer shadow-md">
          確認して閉じる
        </button>
      </div>
    </div>
  </div>

  <script>
    // アイコンの初期化
    lucide.createIcons();

    // グローバル変数
    let map = null;
    let polygonLayer = null;
    let geoData = null;
    let center = { lat: 35.6812, lng: 139.7671 }; // 初期位置: 東京
    let scale = 100;
    let toastTimeout = null;
    
    // 図形の変形ステート変数（回転・反転用）
    let currentRotation = 0;
    let currentFlipX = false;
    let currentFlipY = false;
    
    // ズーム中かどうかを判定するフラグ（ピンチズームちらつき防止用）
    let isZooming = false;
    
    // 現在選択されている地域と、その本来の中心座標
    let currentRegion = "北海道";
    let L_lon = 142.3648; 
    let L_lat = 43.4326;

    // 日本全国の都道府県リスト
    const PREF_NAMES = [
      "北海道", "青森県", "岩手県", "宮城県", "秋田県", "山形県", "福島県", "茨城県", "栃木県", "群馬県",
      "埼玉県", "千葉県", "東京都", "神奈川県", "新潟県", "富山県", "石川県", "福井県", "山梨県", "長野県",
      "岐阜県", "静岡県", "愛知県", "三重県", "滋賀県", "京都府", "大阪府", "兵庫県", "奈良県", "和歌山県",
      "鳥取県", "島根県", "岡山県", "広島県", "山口県", "徳島県", "香川県", "愛媛県", "高知県", "福岡県",
      "佐賀県", "長崎県", "熊本県", "大分県", "宮崎県", "鹿児島県", "沖縄県"
    ];
    let regionDatabase = {};

    // 通信完全遮断時の最終フォールバック用（北海道のみ）
    const fallbackPolygon = [
      [
        [140.14, 41.42], [140.23, 41.73], [140.52, 41.79], [140.96, 41.72], [141.17, 41.86], [141.06, 42.06],
        [140.82, 42.10], [140.50, 42.15], [140.31, 42.23], [140.02, 42.19], [139.86, 42.44], [139.84, 42.63],
        [140.12, 42.86], [140.34, 43.33], [140.48, 43.36], [140.80, 43.19], [141.30, 43.23],
        [141.35, 43.58], [141.40, 43.83], [141.65, 44.08], [141.68, 44.53], [141.73, 44.87], [141.67, 45.12], [141.83, 45.45],
        [141.94, 45.52], [142.18, 45.40], [142.58, 44.93], [142.92, 44.51], [143.53, 44.15], [144.02, 44.02], [144.62, 44.04], [144.97, 44.22],
        [145.32, 44.33], [145.63, 44.35], [145.42, 44.08], [145.02, 43.82],
        [145.18, 43.51], [145.58, 43.41], [145.82, 43.38], [145.62, 43.25], [145.14, 43.11], [144.82, 42.94], [144.27, 42.95],
        [143.84, 42.84], [143.35, 42.28], [143.24, 41.92], [143.14, 42.04],
        [142.82, 42.24], [142.48, 42.36], [142.12, 42.49], [141.68, 42.61], [141.25, 42.46], [141.01, 42.31], [140.97, 42.33],
        [140.48, 42.16], [140.32, 42.08], [140.33, 41.93], [140.61, 41.83], [140.14, 41.42]
      ]
    ];

    function showToast(msg) {
      const toastEl = document.getElementById('toast');
      const msgEl = document.getElementById('toast-message');
      msgEl.innerText = msg;
      toastEl.classList.remove('hidden');
      
      if (toastTimeout) clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => {
        toastEl.classList.add('hidden');
      }, 3000);
    }

    // GeoJSONのGeometryからポリゴンの座標リングを抽出する
    function extractRingsFromGeometry(geometry) {
      let rings = [];
      if (!geometry || !geometry.coordinates) return rings;
      if (geometry.type === 'Polygon') {
        geometry.coordinates.forEach(ring => rings.push(ring));
      } else if (geometry.type === 'MultiPolygon') {
        geometry.coordinates.forEach(polygon => {
          polygon.forEach(ring => rings.push(ring));
        });
      }
      return rings.filter(ring => ring.length >= 3);
    }

    // リングの集まりからバウンディングボックスの中心を計算する
    function calculateBoundsAndCenter(rings) {
      let minLon = 180, maxLon = -180, minLat = 90, maxLat = -90;
      let hasPoints = false;
      rings.forEach(ring => {
        ring.forEach(([lon, lat]) => {
          if (lon < minLon) minLon = lon;
          if (lon > maxLon) maxLon = lon;
          if (lat < minLat) minLat = lat;
          if (lat > maxLat) maxLat = lat;
          hasPoints = true;
        });
      });
      if (!hasPoints) return { lat: 35.6812, lon: 139.7671 }; // 念のためのフォールバック
      return {
        lon: (minLon + maxLon) / 2,
        lat: (minLat + maxLat) / 2
      };
    }

    function updateUI() {
      const displayLat = center.lat;
      let displayLng = center.lng % 360;
      if (displayLng > 180) displayLng -= 360;
      if (displayLng < -180) displayLng += 360;

      const latText = displayLat >= 0 ? 'N' : 'S';
      const lngText = displayLng >= 0 ? 'E' : 'W';

      document.getElementById('coords-display').innerHTML = 
        `${latText} ${Math.abs(displayLat).toFixed(3)}°<br/>${lngText} ${Math.abs(displayLng).toFixed(3)}°`;
      
      document.getElementById('scale-display').innerText = scale.toFixed(1);
    }

    // 図形の変形（回転・反転）をUIに反映して適用するユーティリティ関数
    function toggleFlipButton(btnId, isFlipped) {
      const btn = document.getElementById(btnId);
      if (isFlipped) {
        btn.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
        btn.classList.remove('bg-gray-50', 'border-gray-200', 'text-gray-700');
      } else {
        btn.classList.remove('bg-blue-100', 'border-blue-400', 'text-blue-700');
        btn.classList.add('bg-gray-50', 'border-gray-200', 'text-gray-700');
      }
    }

    function resetTransform() {
      currentRotation = 0;
      currentFlipX = false;
      currentFlipY = false;
      
      const slider = document.getElementById('rotation-slider');
      if(slider) {
        slider.value = 0;
        document.getElementById('rotation-display').innerText = `0°`;
        toggleFlipButton('btn-flip-x', false);
        toggleFlipButton('btn-flip-y', false);
      }
    }

    // ポリゴンの描画と移動処理（回転・反転機能搭載版 ＋ エラーガード）
    function updatePolygon() {
      if (!map || !geoData) return;

      const c_lat = center.lat;
      const c_lon = center.lng;

      const clamped_lat = Math.max(-85, Math.min(85, c_lat));
      
      const L_lat_rad = L_lat * Math.PI / 180;
      const C_lat_rad = clamped_lat * Math.PI / 180;
      
      const toRad = Math.PI / 180;
      const toDeg = 180 / Math.PI;
      
      const lat0 = L_lat * toRad;
      const lon0 = L_lon * toRad;
      const lat1 = clamped_lat * toRad;
      const lon1 = c_lon * toRad;

      // 毎フレーム数万回のループ計算を高速化するため、定数を事前計算
      const sinLat0 = Math.sin(lat0);
      const cosLat0 = Math.cos(lat0);
      const sinLat1 = Math.sin(lat1);
      const cosLat1 = Math.cos(lat1);

      const shifted = geoData.map(ring => {
        const newRing = [];
        
        for (let i = 0; i < ring.length; i++) {
          const [lon, lat] = ring[i];
          const lat_rad = lat * toRad;
          const lon_rad = lon * toRad;

          const dLon = lon_rad - lon0;
          const cosDLon = Math.cos(dLon);
          const sinDLon = Math.sin(dLon);
          
          const sinLatRad = Math.sin(lat_rad);
          const cosLatRad = Math.cos(lat_rad);

          // 誤差対策1: cosDelta が -1.0 〜 1.0 を絶対に超えないように厳密にクランプ
          const cosDeltaInner = sinLat0 * sinLatRad + cosLat0 * cosLatRad * cosDLon;
          const cosDelta = Math.max(-1.0, Math.min(1.0, cosDeltaInner));
          const delta = Math.acos(cosDelta);
          const sinDelta = Math.sin(delta);

          const y = sinDLon * cosLatRad;
          const x = cosLat0 * sinLatRad - sinLat0 * cosLatRad * cosDLon;
          
          // 誤差対策2: deltaが0（中心点そのもの）の時のゼロ除算/不定角を回避
          let theta = (Math.abs(x) < 1e-10 && Math.abs(y) < 1e-10) ? 0 : Math.atan2(y, x);

          // 【追加】図形の反転・回転を球面方位角に適用する
          if (currentFlipX) {
            theta = -theta; // 左右（経度方向）反転
          }
          if (currentFlipY) {
            theta = Math.PI - theta; // 上下（緯度方向）反転
          }
          theta += currentRotation * toRad; // 回転の適用

          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);

          // 誤差対策3: asin の中身も -1.0 〜 1.0 を絶対に超えないように厳密にクランプ
          const asinInner = sinLat1 * cosDelta + cosLat1 * sinDelta * cosTheta;
          const clampedAsinInner = Math.max(-1.0, Math.min(1.0, asinInner));
          const new_lat_rad = Math.asin(clampedAsinInner);

          const new_lon_rad = lon1 + Math.atan2(
            sinTheta * sinDelta * cosLat1,
            cosDelta - sinLat1 * Math.sin(new_lat_rad)
          );

          const final_lat = new_lat_rad * toDeg;
          const final_lon = new_lon_rad * toDeg;

          // 最終安全ガード: 浮動小数点エラーで NaN や Infinity になった頂点は配列から除外する
          if (isFinite(final_lat) && isFinite(final_lon)) {
            newRing.push([final_lat, final_lon]);
          }
        }
        
        // 有効な頂点が3つ以上残ったリングだけを採用
        return newRing.length >= 3 ? newRing : null;
      }).filter(ring => ring !== null);
      
      // 【元の仕様に復元】中心緯度ベースのスケール計算のみ（元の場所でピッタリ100%になる）
      const ratio = Math.cos(L_lat_rad) / Math.cos(C_lat_rad);
      scale = Math.pow(ratio, 2) * 100;

      if (!polygonLayer) {
        polygonLayer = L.polygon(shifted, {
          color: '#ef4444',
          weight: 1.5,
          fillColor: '#ef4444',
          fillOpacity: 0.45,
          interactive: false
        }).addTo(map);
      } else {
        polygonLayer.setLatLngs(shifted);
      }

      updateUI();
    }

    // セレクトボックスの生成とイベント登録
    function buildRegionSelect() {
      const select = document.getElementById('region-select');
      select.innerHTML = '';
      
      // 日本グループ
      const optgroupJapan = document.createElement('optgroup');
      optgroupJapan.label = "日本";
      
      const optionJapan = document.createElement('option');
      optionJapan.value = "日本全体";
      optionJapan.text = "日本全体";
      optgroupJapan.appendChild(optionJapan);

      PREF_NAMES.forEach(name => {
        if (name === "東京都" || name === "鹿児島県" || name === "沖縄県") {
          const parts = name === "東京都" ? ["東京都（本土）", "東京都（島嶼部）", "東京都（全体）"] :
                        name === "鹿児島県" ? ["鹿児島県（本土）", "鹿児島県（島嶼部）", "鹿児島県（全体）"] :
                        ["沖縄県（沖縄本島・周辺）", "沖縄県（先島・大東諸島）", "沖縄県（全体）"];
          parts.forEach(p => {
            if (regionDatabase[p]) {
              const option = document.createElement('option');
              option.value = p;
              option.text = p;
              optgroupJapan.appendChild(option);
            }
          });
        } else {
          if (regionDatabase[name]) {
            const option = document.createElement('option');
            option.value = name;
            option.text = name;
            optgroupJapan.appendChild(option);
          }
        }
      });
      select.appendChild(optgroupJapan);

      select.addEventListener('change', (e) => {
        selectRegion(e.target.value);
      });
    }

    // 指定された地域にデータを切り替える
    function selectRegion(name) {
      if (!regionDatabase[name]) return;
      currentRegion = name;
      geoData = regionDatabase[name].rings;
      L_lat = regionDatabase[name].center.lat;
      L_lon = regionDatabase[name].center.lon;
      
      // 【追加】地域を変えたら回転・反転をリセットする
      resetTransform();
      
      // セレクトボックスの選択状態を合わせる
      document.getElementById('region-select').value = name;
      // タイトルの変更
      document.getElementById('app-title-text').innerText = `どこでも${name}マップ`;
      
      updatePolygon();
    }

    // 頂点を間引く関数（軽量化用）
    function simplifyRing(ring, tolerance) {
      if (ring.length <= 2) return ring;
      const res = [ring[0]];
      let last = ring[0];
      const tolSq = tolerance * tolerance;
      for (let i = 1; i < ring.length - 1; i++) {
        const dx = ring[i][0] - last[0];
        const dy = ring[i][1] - last[1];
        if (dx * dx + dy * dy > tolSq) {
          res.push(ring[i]);
          last = ring[i];
        }
      }
      res.push(ring[ring.length - 1]);
      return res;
    }

    // 地理データの取得（全国データを一括取得）
    async function loadGeoData() {
      try {
        const resJapan = await fetch('https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson');
        if (!resJapan.ok) throw new Error('Japan data fetch failed');
        const dataJapan = await resJapan.json();
        
        let allJapanRings = [];

        dataJapan.features.forEach(f => {
          let prefName = "不明";
          const vals = Object.values(f.properties).map(v => String(v));
          for (const name of PREF_NAMES) {
            if (vals.some(v => v === name || v === name.replace(/(都|府|県)$/, ''))) {
              prefName = name;
              break;
            }
          }
          if (prefName === "不明") {
            let idVal = parseInt(f.properties.id || f.properties.pref || "0");
            if (idVal >= 1 && idVal <= 47) {
              prefName = PREF_NAMES[idVal - 1];
            }
          }

          const rings = extractRingsFromGeometry(f.geometry);
          const optimizedRings = rings.map(r => simplifyRing(r, 0.0015));
          allJapanRings.push(...optimizedRings);

          if (prefName !== "不明") {
            let allKey = (prefName === "東京都" || prefName === "鹿児島県" || prefName === "沖縄県") ? prefName + "（全体）" : prefName;
            if (!regionDatabase[allKey]) regionDatabase[allKey] = { rings: [] };
            regionDatabase[allKey].rings.push(...optimizedRings);

            if (prefName === "東京都") {
              optimizedRings.forEach(ring => {
                const bounds = calculateBoundsAndCenter([ring]);
                let key = bounds.lat > 35.0 ? "東京都（本土）" : "東京都（島嶼部）";
                if (!regionDatabase[key]) regionDatabase[key] = { rings: [] };
                regionDatabase[key].rings.push(ring);
              });
            } else if (prefName === "鹿児島県") {
              optimizedRings.forEach(ring => {
                const bounds = calculateBoundsAndCenter([ring]);
                let key = bounds.lat > 30.9 ? "鹿児島県（本土）" : "鹿児島県（島嶼部）";
                if (!regionDatabase[key]) regionDatabase[key] = { rings: [] };
                regionDatabase[key].rings.push(ring);
              });
            } else if (prefName === "沖縄県") {
              optimizedRings.forEach(ring => {
                const bounds = calculateBoundsAndCenter([ring]);
                let key = (bounds.lon > 127.0 && bounds.lon < 130.0) ? "沖縄県（沖縄本島・周辺）" : "沖縄県（先島・大東諸島）";
                if (!regionDatabase[key]) regionDatabase[key] = { rings: [] };
                regionDatabase[key].rings.push(ring);
              });
            }
          }
        });

        // --- 中心座標の計算 ---
        for (const key in regionDatabase) {
          if (regionDatabase[key] && regionDatabase[key].rings.length > 0) {
            regionDatabase[key].center = calculateBoundsAndCenter(regionDatabase[key].rings);
          }
        }
        
        const japanSimplifiedRings = allJapanRings
          .filter(ring => ring.length > 25)
          .map(ring => simplifyRing(ring, 0.005))
          .filter(ring => ring.length >= 3);

        regionDatabase["日本全体"] = {
          rings: japanSimplifiedRings,
          center: { lat: 37.0, lon: 137.5 } 
        };
        
        if (regionDatabase["北海道"]) {
          regionDatabase["北海道"].center = { lat: 43.4326, lon: 142.3648 };
        }
        if (regionDatabase["東京都（本土）"]) {
          regionDatabase["東京都（本土）"].center = { lat: 35.689, lon: 139.691 }; 
        }

      } catch (e) {
        console.warn("Fetch failed, using fallback polygon.", e);
        showToast('データの取得に失敗しました。内蔵データを使用します。');
        regionDatabase["北海道"] = {
          rings: fallbackPolygon,
          center: { lat: 43.4326, lon: 142.3648 }
        };
      }

      // 準備完了処理
      buildRegionSelect();
      selectRegion("北海道"); // デフォルトは北海道
      document.getElementById('loading-overlay').classList.add('hidden');
    }

    // アプリの初期化
    window.onload = function() {
      // マップ初期化
      map = L.map('map', {
        center: [center.lat, center.lng],
        zoom: 6,
        zoomControl: false
      });
      
      L.control.zoom({ position: 'bottomright' }).addTo(map);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      map.on('zoomstart', () => { isZooming = true; });

      map.on('zoomend', () => {
        isZooming = false;
        const c = map.getCenter();
        center = { lat: c.lat, lng: c.lng };
        updatePolygon();
      });

      let moveRaf = null;
      map.on('move', () => {
        if (isZooming) return;
        const c = map.getCenter(); 
        center = { lat: c.lat, lng: c.lng };
        if (!moveRaf) {
          moveRaf = requestAnimationFrame(() => {
            updatePolygon(); 
            moveRaf = null;
          });
        }
      });

      map.on('moveend', () => {
        const c = map.getCenter();
        const MAX_LAT = 84.5; 
        if (c.lat > MAX_LAT + 0.05) {
          map.panTo([MAX_LAT, c.lng], { animate: true, duration: 0.4 });
        } else if (c.lat < -MAX_LAT - 0.05) {
          map.panTo([-MAX_LAT, c.lng], { animate: true, duration: 0.4 });
        }
      });

      // --- 各種ボタンイベント ---
      document.getElementById('btn-home').addEventListener('click', () => {
        if (map) map.flyTo([L_lat, L_lon], 6, { duration: 1.5 });
      });

      document.getElementById('btn-current-location').addEventListener('click', () => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              if (map) map.flyTo([pos.coords.latitude, pos.coords.longitude], 6, { duration: 1.5 });
            },
            () => { showToast('現在地の取得が許可されていないか、取得に失敗しました。'); }
          );
        } else {
          showToast('お使いのブラウザは現在地取得に対応していません。');
        }
      });

      // 【追加】図形操作パネルのトグルと操作イベント
      const btnToggleControls = document.getElementById('btn-toggle-controls');
      const controlsPanel = document.getElementById('controls-panel');
      const iconToggle = document.getElementById('icon-toggle-controls');

      btnToggleControls.addEventListener('click', () => {
        controlsPanel.classList.toggle('hidden');
        iconToggle.classList.toggle('rotate-180');
      });

      document.getElementById('rotation-slider').addEventListener('input', (e) => {
        currentRotation = parseInt(e.target.value, 10);
        document.getElementById('rotation-display').innerText = `${currentRotation}°`;
        requestAnimationFrame(updatePolygon);
      });

      document.getElementById('btn-flip-x').addEventListener('click', () => {
        currentFlipX = !currentFlipX;
        toggleFlipButton('btn-flip-x', currentFlipX);
        requestAnimationFrame(updatePolygon);
      });

      document.getElementById('btn-flip-y').addEventListener('click', () => {
        currentFlipY = !currentFlipY;
        toggleFlipButton('btn-flip-y', currentFlipY);
        requestAnimationFrame(updatePolygon);
      });

      document.getElementById('btn-reset-transform').addEventListener('click', () => {
        resetTransform();
        requestAnimationFrame(updatePolygon);
      });

      // 留意事項モーダルのイベントリスナー
      const noticeModal = document.getElementById('notice-modal');
      const closeNoticeBtn = document.getElementById('close-notice-btn');
      
      const closeModal = () => {
        noticeModal.classList.add('opacity-0');
        setTimeout(() => {
          noticeModal.classList.add('hidden');
        }, 300);
      };

      closeNoticeBtn.addEventListener('click', closeModal);
      noticeModal.addEventListener('click', (e) => {
        if (e.target === noticeModal) closeModal();
      });

      // データのロード開始
      loadGeoData();
      updateUI(); 
    };
  </script>
</body>
</html>