<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8ZD2TRY287"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8ZD2TRY287');
</script>  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>どこでも北海道マップ</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    /* Tailwindのデフォルトフォントを適用 */
    body { font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
    /* アイコンの表示スタイル調整 */
    i[data-lucide] { display: inline-block; }
  </style>
</head>
<body class="relative w-full h-screen bg-[#e5e7eb] overflow-hidden">

  <!-- ローディング画面 -->
  <div id="loading-overlay" class="absolute inset-0 z-[2000] bg-white/80 flex flex-col items-center justify-center backdrop-blur-sm transition-opacity duration-300">
    <div class="w-10 h-10 border-4 border-red-500 border-t-transparent rounded-full animate-spin mb-4"></div>
    <div class="text-gray-700 font-medium tracking-wide">地理データを読み込み中...</div>
    <div class="text-xs text-gray-400 mt-2">日本全国の高精細なデータを取得しています</div>
  </div>

  <!-- マップコンテナ -->
  <div id="map" class="w-full h-full absolute inset-0 z-0"></div>
  
  <!-- 中央の十字レティクル（ターゲット） -->
  <div class="absolute inset-0 pointer-events-none z-[1000] flex items-center justify-center">
    <div class="relative w-10 h-10 opacity-50">
      <div class="absolute top-1/2 left-0 w-full h-[2px] bg-gray-900 -translate-y-1/2 rounded-full"></div>
      <div class="absolute left-1/2 top-0 w-[2px] h-full bg-gray-900 -translate-x-1/2 rounded-full"></div>
      <div class="absolute inset-0 border-2 border-gray-900 rounded-full scale-50"></div>
    </div>
  </div>

  <!-- タイトル・説明パネル (左上) -->
  <div class="absolute top-4 left-4 z-[1000] bg-white/95 backdrop-blur-md p-3 sm:p-5 rounded-xl sm:rounded-2xl shadow-xl border border-gray-100 max-w-[55%] sm:max-w-[320px]">
    <h1 class="text-sm sm:text-xl font-bold text-gray-800 flex items-center gap-1.5 sm:gap-2 sm:mb-3">
      <i data-lucide="map" class="w-4 h-4 sm:w-6 sm:h-6 text-red-500 shrink-0"></i>
      <span id="app-title-text" class="truncate">どこでも北海道マップ</span>
    </h1>
    
    <div class="hidden sm:block">
      <p class="text-sm text-gray-600 mb-4 leading-relaxed">
        地図をドラッグすると、画面中央に選択した地域がついてきます。世界中の様々な地域と実際の大きさを比べてみましょう。
      </p>
      <div class="flex items-start gap-2 text-xs text-blue-800 bg-blue-50/80 p-3 rounded-xl border border-blue-100 mb-4">
        <i data-lucide="info" class="w-4 h-4 shrink-0 mt-0.5 text-blue-500"></i>
        <p class="leading-relaxed">
          メルカトル図法の特性を完全再現。赤道に近づくほど小さくなり、極地に近づくほど巨大化し、さらに図形自体も歪みます。
        </p>
      </div>
    </div>

    <!-- 地域選択プルダウン -->
    <div class="mt-2 sm:mt-0">
      <select id="region-select" class="w-full bg-gray-50/90 border border-gray-200 text-gray-800 text-xs sm:text-sm rounded-xl focus:ring-blue-500 focus:border-blue-500 block p-2 sm:p-2.5 shadow-inner cursor-pointer outline-none transition-all">
        <option value="北海道">北海道 (読み込み中...)</option>
      </select>
      
      <!-- バグ報告リンク -->
      <div class="mt-2 text-right">
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSfh55H0B8LKC9N7ed3hGXwA4duPPNhTMbcT6oQgCS4tX4_CjA/viewform?usp=header" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-[10px] sm:text-xs text-gray-400 hover:text-gray-600 transition-colors cursor-pointer">
          <i data-lucide="bug" class="w-3 h-3"></i>
          <span>バグ・不具合を報告</span>
        </a>
      </div>
    </div>
  </div>

  <!-- ステータスパネル (右上) -->
  <div class="absolute top-4 right-4 z-[1000] bg-white/95 backdrop-blur-md p-3 sm:p-5 rounded-xl sm:rounded-2xl shadow-xl border border-gray-100 min-w-min sm:min-w-[220px]">
    <div class="hidden sm:block">
      <div class="text-xs font-semibold text-gray-400 tracking-wider mb-1 uppercase">現在地の中心座標</div>
      <div id="coords-display" class="font-mono text-sm text-gray-700 mb-4 bg-gray-50 p-2 rounded-lg border border-gray-100">
        N 35.681°<br/>E 139.767°
      </div>
    </div>
    
    <div class="text-[10px] sm:text-xs font-semibold text-gray-400 tracking-wider mb-0 sm:mb-1 uppercase leading-tight">
      見た目の大きさ <br class="hidden sm:inline"/><span class="text-[8px] sm:text-[10px] font-normal lowercase">(対 本来の位置)</span>
    </div>
    <div class="flex items-baseline gap-1 mt-0.5 sm:mt-1">
      <span id="scale-display" class="text-xl sm:text-3xl font-black text-red-500 tracking-tight">100.0</span>
      <span class="text-xs sm:text-sm text-gray-500 font-medium">%</span>
    </div>
  </div>

  <!-- コントロールボタン (下部中央) -->
  <div class="absolute bottom-6 sm:bottom-8 left-1/2 -translate-x-1/2 z-[1000] flex gap-2 sm:gap-3 w-full max-w-[90%] sm:max-w-sm justify-center">
    <button id="btn-home" class="flex-1 flex items-center justify-center gap-1.5 sm:gap-2 bg-white px-3 sm:px-4 py-2.5 sm:py-3.5 rounded-xl sm:rounded-2xl shadow-lg font-medium text-sm sm:text-base text-gray-700 hover:bg-gray-50 transition-all active:scale-95 border border-gray-200 cursor-pointer">
      <i data-lucide="map-pin" class="w-4 h-4 sm:w-5 sm:h-5 text-red-500"></i>
      元の位置
    </button>
    <button id="btn-current-location" class="flex-1 flex items-center justify-center gap-1.5 sm:gap-2 bg-blue-600 px-3 sm:px-4 py-2.5 sm:py-3.5 rounded-xl sm:rounded-2xl shadow-lg font-medium text-sm sm:text-base text-white hover:bg-blue-700 transition-all active:scale-95 cursor-pointer">
      <i data-lucide="navigation" class="w-4 h-4 sm:w-5 sm:h-5"></i>
      現在地へ
    </button>
  </div>

  <!-- トースト通知 -->
  <div id="toast" class="hidden absolute bottom-24 left-1/2 -translate-x-1/2 z-[1100] bg-gray-800/90 backdrop-blur-sm text-white px-6 py-3 rounded-full shadow-2xl text-sm font-medium animate-bounce transition-opacity">
    <span id="toast-message"></span>
  </div>

  <script>
    // アイコンの初期化
    lucide.createIcons();

    // グローバル変数
    let map = null;
    let polygonLayer = null;
    let geoData = null;
    let center = { lat: 35.6812, lng: 139.7671 }; // 初期位置: 東京
    let scale = 100;
    let toastTimeout = null;
    
    // ズーム中かどうかを判定するフラグ（ピンチズームちらつき防止用）
    let isZooming = false;
    
    // 現在選択されている地域と、その本来の中心座標
    let currentRegion = "北海道";
    let L_lon = 142.3648; 
    let L_lat = 43.4326;

    // 日本全国の都道府県リスト
    const PREF_NAMES = [
      "北海道", "青森県", "岩手県", "宮城県", "秋田県", "山形県", "福島県", "茨城県", "栃木県", "群馬県",
      "埼玉県", "千葉県", "東京都", "神奈川県", "新潟県", "富山県", "石川県", "福井県", "山梨県", "長野県",
      "岐阜県", "静岡県", "愛知県", "三重県", "滋賀県", "京都府", "大阪府", "兵庫県", "奈良県", "和歌山県",
      "鳥取県", "島根県", "岡山県", "広島県", "山口県", "徳島県", "香川県", "愛媛県", "高知県", "福岡県",
      "佐賀県", "長崎県", "熊本県", "大分県", "宮崎県", "鹿児島県", "沖縄県"
    ];
    let regionDatabase = {};

    // 通信完全遮断時の最終フォールバック用（北海道のみ）
    const fallbackPolygon = [
      [
        [140.14, 41.42], [140.23, 41.73], [140.52, 41.79], [140.96, 41.72], [141.17, 41.86], [141.06, 42.06],
        [140.82, 42.10], [140.50, 42.15], [140.31, 42.23], [140.02, 42.19], [139.86, 42.44], [139.84, 42.63],
        [140.12, 42.86], [140.34, 43.33], [140.48, 43.36], [140.80, 43.19], [141.30, 43.23],
        [141.35, 43.58], [141.40, 43.83], [141.65, 44.08], [141.68, 44.53], [141.73, 44.87], [141.67, 45.12], [141.83, 45.45],
        [141.94, 45.52], [142.18, 45.40], [142.58, 44.93], [142.92, 44.51], [143.53, 44.15], [144.02, 44.02], [144.62, 44.04], [144.97, 44.22],
        [145.32, 44.33], [145.63, 44.35], [145.42, 44.08], [145.02, 43.82],
        [145.18, 43.51], [145.58, 43.41], [145.82, 43.38], [145.62, 43.25], [145.14, 43.11], [144.82, 42.94], [144.27, 42.95],
        [143.84, 42.84], [143.35, 42.28], [143.24, 41.92], [143.14, 42.04],
        [142.82, 42.24], [142.48, 42.36], [142.12, 42.49], [141.68, 42.61], [141.25, 42.46], [141.01, 42.31], [140.97, 42.33],
        [140.48, 42.16], [140.32, 42.08], [140.33, 41.93], [140.61, 41.83], [140.14, 41.42]
      ]
    ];

    function showToast(msg) {
      const toastEl = document.getElementById('toast');
      const msgEl = document.getElementById('toast-message');
      msgEl.innerText = msg;
      toastEl.classList.remove('hidden');
      
      if (toastTimeout) clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => {
        toastEl.classList.add('hidden');
      }, 3000);
    }

    // GeoJSONのGeometryからポリゴンの座標リングを抽出する
    function extractRingsFromGeometry(geometry) {
      let rings = [];
      if (!geometry || !geometry.coordinates) return rings;
      if (geometry.type === 'Polygon') {
        geometry.coordinates.forEach(ring => rings.push(ring));
      } else if (geometry.type === 'MultiPolygon') {
        geometry.coordinates.forEach(polygon => {
          polygon.forEach(ring => rings.push(ring));
        });
      }
      return rings.filter(ring => ring.length >= 3);
    }

    // リングの集まりからバウンディングボックスの中心を計算する
    function calculateBoundsAndCenter(rings) {
      let minLon = 180, maxLon = -180, minLat = 90, maxLat = -90;
      let hasPoints = false;
      rings.forEach(ring => {
        ring.forEach(([lon, lat]) => {
          if (lon < minLon) minLon = lon;
          if (lon > maxLon) maxLon = lon;
          if (lat < minLat) minLat = lat;
          if (lat > maxLat) maxLat = lat;
          hasPoints = true;
        });
      });
      if (!hasPoints) return { lat: 35.6812, lon: 139.7671 }; // 念のためのフォールバック
      return {
        lon: (minLon + maxLon) / 2,
        lat: (minLat + maxLat) / 2
      };
    }

    function updateUI() {
      const displayLat = center.lat;
      let displayLng = center.lng % 360;
      if (displayLng > 180) displayLng -= 360;
      if (displayLng < -180) displayLng += 360;

      const latText = displayLat >= 0 ? 'N' : 'S';
      const lngText = displayLng >= 0 ? 'E' : 'W';

      document.getElementById('coords-display').innerHTML = 
        `${latText} ${Math.abs(displayLat).toFixed(3)}°<br/>${lngText} ${Math.abs(displayLng).toFixed(3)}°`;
      
      document.getElementById('scale-display').innerText = scale.toFixed(1);
    }

    // ポリゴンの描画と移動処理（球面三角法を用いた厳密な計算 ＋ 浮動小数点エラーの完全ガード版）
    function updatePolygon() {
      if (!map || !geoData) return;

      const c_lat = center.lat;
      const c_lon = center.lng;

      const clamped_lat = Math.max(-85, Math.min(85, c_lat));
      
      const L_lat_rad = L_lat * Math.PI / 180;
      const C_lat_rad = clamped_lat * Math.PI / 180;
      const ratio = Math.cos(L_lat_rad) / Math.cos(C_lat_rad);
      scale = Math.pow(ratio, 2) * 100;

      const toRad = Math.PI / 180;
      const toDeg = 180 / Math.PI;
      
      const lat0 = L_lat * toRad;
      const lon0 = L_lon * toRad;
      const lat1 = clamped_lat * toRad;
      const lon1 = c_lon * toRad;

      // 毎フレーム数万回のループ計算を高速化するため、定数を事前計算
      const sinLat0 = Math.sin(lat0);
      const cosLat0 = Math.cos(lat0);
      const sinLat1 = Math.sin(lat1);
      const cosLat1 = Math.cos(lat1);

      // grokの指摘箇所：ここでNaNや無限大が発生して巨大化していたのを完全にブロックします
      const shifted = geoData.map(ring => {
        const newRing = [];
        
        for (let i = 0; i < ring.length; i++) {
          const [lon, lat] = ring[i];
          const lat_rad = lat * toRad;
          const lon_rad = lon * toRad;

          const dLon = lon_rad - lon0;
          const cosDLon = Math.cos(dLon);
          const sinDLon = Math.sin(dLon);
          
          const sinLatRad = Math.sin(lat_rad);
          const cosLatRad = Math.cos(lat_rad);

          // 誤差対策1: cosDelta が -1.0 〜 1.0 を絶対に超えないように厳密にクランプ
          const cosDeltaInner = sinLat0 * sinLatRad + cosLat0 * cosLatRad * cosDLon;
          const cosDelta = Math.max(-1.0, Math.min(1.0, cosDeltaInner));
          const delta = Math.acos(cosDelta);
          const sinDelta = Math.sin(delta);

          const y = sinDLon * cosLatRad;
          const x = cosLat0 * sinLatRad - sinLat0 * cosLatRad * cosDLon;
          
          // 誤差対策2: deltaが0（中心点そのもの）の時のゼロ除算/不定角を回避
          const theta = (Math.abs(x) < 1e-10 && Math.abs(y) < 1e-10) ? 0 : Math.atan2(y, x);

          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);

          // 誤差対策3: asin の中身も -1.0 〜 1.0 を絶対に超えないように厳密にクランプ
          const asinInner = sinLat1 * cosDelta + cosLat1 * sinDelta * cosTheta;
          const clampedAsinInner = Math.max(-1.0, Math.min(1.0, asinInner));
          const new_lat_rad = Math.asin(clampedAsinInner);

          const new_lon_rad = lon1 + Math.atan2(
            sinTheta * sinDelta * cosLat1,
            cosDelta - sinLat1 * Math.sin(new_lat_rad)
          );

          const final_lat = new_lat_rad * toDeg;
          const final_lon = new_lon_rad * toDeg;

          // ★最終安全ガード: 浮動小数点エラーで NaN や Infinity になった頂点は配列から除外する
          if (isFinite(final_lat) && isFinite(final_lon)) {
            newRing.push([final_lat, final_lon]);
          }
        }
        
        // 有効な頂点が3つ以上残ったリングだけを採用
        return newRing.length >= 3 ? newRing : null;
      }).filter(ring => ring !== null);

      if (!polygonLayer) {
        polygonLayer = L.polygon(shifted, {
          color: '#ef4444',
          weight: 1.5,
          fillColor: '#ef4444',
          fillOpacity: 0.45,
          interactive: false
        }).addTo(map);
      } else {
        polygonLayer.setLatLngs(shifted);
      }

      updateUI();
    }

    // セレクトボックスの生成とイベント登録
    function buildRegionSelect() {
      const select = document.getElementById('region-select');
      select.innerHTML = '';
      
      const optionJapan = document.createElement('option');
      optionJapan.value = "日本全体";
      optionJapan.text = "日本全体";
      select.appendChild(optionJapan);

      PREF_NAMES.forEach(name => {
        // 島嶼部が広範囲な県については、分割した選択肢も追加する
        if (name === "東京都" || name === "鹿児島県" || name === "沖縄県") {
          const parts = name === "東京都" ? ["東京都（本土）", "東京都（島嶼部）", "東京都（全体）"] :
                        name === "鹿児島県" ? ["鹿児島県（本土）", "鹿児島県（島嶼部）", "鹿児島県（全体）"] :
                        ["沖縄県（沖縄本島・周辺）", "沖縄県（先島・大東諸島）", "沖縄県（全体）"];
          parts.forEach(p => {
            if (regionDatabase[p]) {
              const option = document.createElement('option');
              option.value = p;
              option.text = p;
              select.appendChild(option);
            }
          });
        } else {
          // その他の県はそのまま追加
          if (regionDatabase[name]) {
            const option = document.createElement('option');
            option.value = name;
            option.text = name;
            select.appendChild(option);
          }
        }
      });

      select.addEventListener('change', (e) => {
        selectRegion(e.target.value);
      });
    }

    // 指定された地域にデータを切り替える
    function selectRegion(name) {
      if (!regionDatabase[name]) return;
      currentRegion = name;
      geoData = regionDatabase[name].rings;
      L_lat = regionDatabase[name].center.lat;
      L_lon = regionDatabase[name].center.lon;
      
      // セレクトボックスの選択状態を合わせる
      document.getElementById('region-select').value = name;
      // タイトルの変更
      document.getElementById('app-title-text').innerText = `どこでも${name}マップ`;
      
      updatePolygon();
    }

    // 頂点を間引く関数（軽量化用）
    function simplifyRing(ring, tolerance) {
      if (ring.length <= 2) return ring;
      const res = [ring[0]];
      let last = ring[0];
      const tolSq = tolerance * tolerance;
      for (let i = 1; i < ring.length - 1; i++) {
        const dx = ring[i][0] - last[0];
        const dy = ring[i][1] - last[1];
        if (dx * dx + dy * dy > tolSq) {
          res.push(ring[i]);
          last = ring[i];
        }
      }
      res.push(ring[ring.length - 1]);
      return res;
    }

    // 地理データの取得（全国データを一括取得）
    async function loadGeoData() {
      try {
        const res = await fetch('https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson');
        if (!res.ok) throw new Error('Fetch failed');
        const data = await res.json();
        
        let allJapanRings = [];

        // 全国のFeatureを都道府県ごとに分類
        data.features.forEach(f => {
          let prefName = "不明";
          const vals = Object.values(f.properties).map(v => String(v));
          for (const name of PREF_NAMES) {
            // "東京都"と"東京"などの揺れに対応
            if (vals.some(v => v === name || v === name.replace(/(都|府|県)$/, ''))) {
              prefName = name;
              break;
            }
          }
          if (prefName === "不明") {
            let idVal = parseInt(f.properties.id || f.properties.pref || "0");
            if (idVal >= 1 && idVal <= 47) {
              prefName = PREF_NAMES[idVal - 1];
            }
          }

          const rings = extractRingsFromGeometry(f.geometry);
          // 【grokの提案を採用】 0.0005 → 0.0015 に緩和し、頂点数を減らして計算負荷とエラー発生率を下げる
          const optimizedRings = rings.map(r => simplifyRing(r, 0.0015));
          allJapanRings.push(...optimizedRings);

          if (prefName !== "不明") {
            // ① 元々の都道府県全体としての保存（東京などは「（全体）」として保存）
            let allKey = (prefName === "東京都" || prefName === "鹿児島県" || prefName === "沖縄県") ? prefName + "（全体）" : prefName;
            if (!regionDatabase[allKey]) regionDatabase[allKey] = { rings: [] };
            regionDatabase[allKey].rings.push(...optimizedRings);

            // ② 広域な島嶼部を持つ県については、緯度経度から本土と島嶼部に分割して保存
            if (prefName === "東京都") {
              optimizedRings.forEach(ring => {
                const bounds = calculateBoundsAndCenter([ring]);
                let key = bounds.lat > 35.0 ? "東京都（本土）" : "東京都（島嶼部）";
                if (!regionDatabase[key]) regionDatabase[key] = { rings: [] };
                regionDatabase[key].rings.push(ring);
              });
            } else if (prefName === "鹿児島県") {
              optimizedRings.forEach(ring => {
                const bounds = calculateBoundsAndCenter([ring]);
                // 佐多岬(約30.99度)と種子島(約30.8度)の間を境界線にする
                let key = bounds.lat > 30.9 ? "鹿児島県（本土）" : "鹿児島県（島嶼部）";
                if (!regionDatabase[key]) regionDatabase[key] = { rings: [] };
                regionDatabase[key].rings.push(ring);
              });
            } else if (prefName === "沖縄県") {
              optimizedRings.forEach(ring => {
                const bounds = calculateBoundsAndCenter([ring]);
                // 東経127度〜130度の範囲を沖縄本島・周辺諸島として分離
                let key = (bounds.lon > 127.0 && bounds.lon < 130.0) ? "沖縄県（沖縄本島・周辺）" : "沖縄県（先島・大東諸島）";
                if (!regionDatabase[key]) regionDatabase[key] = { rings: [] };
                regionDatabase[key].rings.push(ring);
              });
            }
          }
        });

        // 各都道府県（および分割された地域）の中心座標を計算
        for (const key in regionDatabase) {
          if (regionDatabase[key] && regionDatabase[key].rings.length > 0) {
            regionDatabase[key].center = calculateBoundsAndCenter(regionDatabase[key].rings);
          }
        }
        
        // 日本全体はデータ量が膨大で重くなるため、極小の島を除外し、少し強めに間引いて軽量化
        const japanSimplifiedRings = allJapanRings
          .filter(ring => ring.length > 25) // 小さすぎる島を除外
          .map(ring => simplifyRing(ring, 0.005)) // さらに間引いて軽量化
          .filter(ring => ring.length >= 3);

        regionDatabase["日本全体"] = {
          rings: japanSimplifiedRings,
          center: { lat: 37.0, lon: 137.5 } 
        };
        
        // 中心位置が海などにならないように微調整（慣れ親しんだ位置にするため）
        if (regionDatabase["北海道"]) {
          regionDatabase["北海道"].center = { lat: 43.4326, lon: 142.3648 };
        }
        if (regionDatabase["東京都（本土）"]) {
          regionDatabase["東京都（本土）"].center = { lat: 35.689, lon: 139.691 }; // 新宿付近
        }

      } catch (e) {
        console.warn("Fetch failed, using fallback polygon.", e);
        showToast('高精細データの取得に失敗しました。内蔵データを使用します。');
        regionDatabase["北海道"] = {
          rings: fallbackPolygon,
          center: { lat: 43.4326, lon: 142.3648 }
        };
      }

      // 準備完了処理
      buildRegionSelect();
      selectRegion("北海道"); // デフォルトは北海道
      document.getElementById('loading-overlay').classList.add('hidden');
    }

    // アプリの初期化
    window.onload = function() {
      // マップ初期化
      map = L.map('map', {
        center: [center.lat, center.lng],
        zoom: 6,
        zoomControl: false // 右下に配置し直すためデフォルトをオフ
      });
      
      L.control.zoom({ position: 'bottomright' }).addTo(map);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // 【ピンチズームちらつき対策】ズーム開始時にフラグを立てる
      map.on('zoomstart', () => {
        isZooming = true;
      });

      // 【ピンチズームちらつき対策】ズーム終了時にフラグを下ろし、確定した位置で再計算・描画を行う
      map.on('zoomend', () => {
        isZooming = false;
        const c = map.getCenter();
        center = { lat: c.lat, lng: c.lng };
        updatePolygon();
      });

      // 中心座標が動いた時のイベント（requestAnimationFrameで描画頻度を最適化し、軽量化）
      let moveRaf = null;
      map.on('move', () => {
        // 【ピンチズームちらつき対策】ズーム中は再計算をスキップし、Leafletの標準アニメーションに任せる
        if (isZooming) return;

        const c = map.getCenter(); 
        center = { lat: c.lat, lng: c.lng };
        if (!moveRaf) {
          moveRaf = requestAnimationFrame(() => {
            updatePolygon(); 
            moveRaf = null;
          });
        }
      });

      // 指を離した時（移動完了時）に極地へ行きすぎていたらゴム紐のように引き戻す
      map.on('moveend', () => {
        const c = map.getCenter();
        const MAX_LAT = 84.5; 
        
        // 無限ループ(RangeError)を防ぐため、0.05度の「遊び」を持たせる
        if (c.lat > MAX_LAT + 0.05) {
          map.panTo([MAX_LAT, c.lng], { animate: true, duration: 0.4 });
        } else if (c.lat < -MAX_LAT - 0.05) {
          map.panTo([-MAX_LAT, c.lng], { animate: true, duration: 0.4 });
        }
      });

      // ボタンのイベントリスナー
      document.getElementById('btn-home').addEventListener('click', () => {
        if (map) map.flyTo([L_lat, L_lon], 6, { duration: 1.5 });
      });

      document.getElementById('btn-current-location').addEventListener('click', () => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              if (map) map.flyTo([pos.coords.latitude, pos.coords.longitude], 6, { duration: 1.5 });
            },
            () => {
              showToast('現在地の取得が許可されていないか、取得に失敗しました。');
            }
          );
        } else {
          showToast('お使いのブラウザは現在地取得に対応していません。');
        }
      });

      // データのロード開始
      loadGeoData();
      updateUI(); 
    };
  </script>
</body>
</html>
